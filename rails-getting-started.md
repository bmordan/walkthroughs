# Rails Getting Started

Rails is a framework for creating RESTful applications. It has been developed for many years and has lots of production grade features you can take advantage of. Now you have learnt a little bit of Ruby, you can start to create powerful applications using Ruby on Rails.

## Installation

`gem install rails`

This is going to give you the `rails` CLI tool you can use in your shell. You can test your installation with the command `rails --version`

## Creating a project

```
rails new todo-list
```
this is going to generate your first rails project in a folder called `todo-list` when its done nagivate into the folder.

## Hello World

Lets start with a really simple "hello world". You'll see for yourself rails has generated ALOT of files and folders. Don't worry as you use rails you will learn about what goes where. We are going to start in the config folder:

```ruby
# /config/routes.rb

Rails.application.routes.draw do
  root to: "hello#world"
end
```

this introduces us to routing and controllers. Routing is defined in this file. The routes map URLs to ruby request handlers or "controllers". Controllers control incoming requests and make sure they call the right ruby method to handle the request. Above we are saying the root `http://localhost:3000/` should use the "hello" controller `HelloController` and call the "world" method within that controller.

For this to work we need to generate a controller.

```
rails g controller hello
```
the g is short for "generate" and its going to create a few files and a bit of wiring. The file we now want to edit is below:

```ruby
# /app/controllers/hello_controller.rb

class HelloController < ApplicationController
  def world
  end
end
```
above we create the method that handles that request. It is enough to just create the method. To render some html if you now create the following:
```html
<!-- /app/views/hello/world.html.erb -->

<h1>Hello World</h1>
```
OK we are ready to spin up out first rails app.
```
rails s
```
the "s" is short for "server". Go to http://localhost:3000/ and enjoy.

## MVC

OK thats easy. Seems complex for a simple task, but rails is really geared toward complex tasks, not simple ones. Now lets create a todo list and drive UI with some data. In the following steps we are going to create a simple todo list that uses a model, a controller and a couple of views, and a partial. We want to write 7 RESTful routes in our controller, and perform all the CRUD oppertations. Thats going to give us a good introduction to rails.

```
rails g model Todo task:string status:integer
```
this generates our model. Under the hood rails is using ActiveRecord, we also pass in our schema, a property called "task" that is a string and a property called "status" that is a number. This generates an ActiveRecord model, a migration and some test files with the boilerplate already written for some tests. Lets create our database table.

```sh
rails db:migrate
```
Easy. Now lets create our controller. I can pass to the controller all the methods I want to use in my controller (which is all 7)

```
rails g controller todos index new create update destroy
```
Notice the controller is plural. The `todos_controller.rb` file has all the methods in it and we have a views folder with all our files also created. Now lets work our way through the CRUD cycle. The first thing to do it create new todos. Lets build the form.

```html
<!-- /app/views/todos/new.html.erb -->

<%=form_with model: @todo, local: true do |f|%>
    <%=f.text_field :task, placeholder: "add a task"%>
    <%=f.submit%>
<%end%>
```
woo! that's some weird looking form. This is the rails FormHelper. Its a ruby function that generates a html form. You can now visit `http://localhost:3000/todos/new` and see the form. Can you see the extra pieces of data that have been generated by the form helper (right click inspect)? What is the problem with this form?
```html
<form action="/todos/new" accept-charset="UTF-8" method="post"><input type="hidden" name="authenticity_token" value="D5uhwa2ih3fYWZG4cBq3YsyQKtDFO/mRnIHrCXh/pe9+k5mVtfjB7yX3emrbxyBTdKvL7aVD4gfMf0It5C6DGQ==" />
    <input placeholder="add a task" type="text" name="task" id="task" />
    <input type="submit" name="commit" value="Save " data-disable-with="Save " />
</form>
```
Yep we want to POST to `/todos` not `/todos/new` when the form is submitted. This is the RESTful way. Lets draw a set of routes for this resource. First stop the server (you should also run the command `spring stop` if your shell hangs!). Then type.

```
rails routes
```
you should get something like this:

which is not quite right. We can't see any of the HTML verbs like PATCH or DELETE. Lets edit the routes file
```ruby
# /config/routes.rb

Rails.application.routes.draw do
  resource :todos
  root "hello#world"
end
```
Now run the `rails routes` command again and see the difference. Now lets spin up the server again and see what our form is pointing to now. This is really important when working with rails. This is all the way RESTful and these conventions provide the rails for your project. You need to work with the routing to get the most pace out of development time. The form helpers help you create forms that route to the right places.

Lets try to create a todo again. We will need to pass down to the template an empty instance of the model, then the form helper will be able to figure which route to POST to etc. Update your "new" method in your `todos_controller.rb`.
```ruby
  def new
    @todo = Todo.new
  end
```
Now when you load the form, you should see your form is set to POST to `/todos` which is what we want. We have an endpoint that we can post to now. Lets write the code to handle creating new todos. In the `todos_controller.rb` in the create method you'll receive a payload on `params` lets verify that payload and then create our new todo, then redirect to the main index page (which will be empty).
```ruby
# /app/controllers/todos/todos_controller.rb

  def create
    todo = Todo.create(todo_params)
    redirect_to todos_url
  end

  =begin
    there are other methods in this file. After all of them add the keyword `private`
    then on a new line after that create the function below
  =end

  private

  def todo_params
    params.require("todo").permit(:task)
  end
```
One more thing. We want our todo to be created with a default value of 0 for the status. The place to do that is in the model.
```ruby
# /app/models/todo.rb
class Todo < ApplicationRecord
    attribute :status, default: 0
end
```
## Views
Now we should have a todo. Lets view them all on the index page. For this just update the following function in the `todos_controller.rb`

```ruby
# /app/controllers/todo_controller.rb

  def show
    @todos = Todo.all
  end
```
and in the view lets iterate over the todos. We should also update our root route to be the index.
```html
<!-- /app/views/todos/show.html.erb -->
<h1>Todos</h1>
<%@todos.each do |todo|%>
    <article>
        <span style="text-decoration:<%=["none", "line-through"][todo.status]%>"><%=todo.task%></span>
        <%if todo.status == 0%>
            <%=link_to "Done", todos_url(todo), method: :patch%>
        <%else%>
            <%=link_to "Delete", todos_url(todo), method: :delete%>
        <%end%>
    </article>
<%end%>
```
There is a lot here too. Lets go through it. We are passing in all the todos to the template and iterating over them. If the todo has a status of 0 we show the "done" button. If it is done we show the "delete" button and line-through the text. There is a link helper into which we are passing three arguments, the text to display, the url and the method because we don't want the default GET method. Can you see we get the right url by calling a method with the instance of the iterable. The method is called `todos_url` and is called a template helper. Have a look at the html this template generates.

Now we have two more CRUD actions to encode. Lets to the update first, then the delete. First of all we need to update our routes file and add our two new bespoke routes.
```ruby
Rails.application.routes.draw do
  root "todos#show"
  resource :todos
  patch "/todos/:id", to: "todos#update", as: "todos_update"
  delete "/todos/:id", to: "todos#destroy", as: "todos_delete"
end
```

This is slightly unrestful because is such a small app. Best practice would have an edit form on `/todos/edit/1`. That form would then send as a PATCH to `/todos` with its payload. We are just doing a simple canned update of status 0 to 1. Then update your `todos_controller.rb`.

```ruby
  def update
    todo = Todo.find(params[:id])
    todo.update({status: 1})
    redirect_to todos_url
  end

  def destroy
    Todo.destroy(params[:id])
    redirect_to todos_url
  end
```
Finally to complete the CRUD cycle lets bring the form from the other route and just have it on the same page. I want to do this to show you how partials work too. First of all make a partial.

## Partials

Rename you `/app/views/todos/new.html.erb` to `/app/views/todos/_new.html.erb`.
Now lets use the partial in our `show.html.erb`
```html
<h1>Todos</h1>
<%@todos.each do |todo|%>
    <article>
        <span style="text-decoration:<%=["none", "line-through"][todo.status]%>"><%=todo.task%></span>
        <%if todo.status == 0%>
            <%=link_to "Done", todos_update_url(todo), method: :patch %>
        <%else%>
            <%=link_to "Delete", todos_delete_url(todo), method: :delete %>
        <%end%>
    </article>
<%end%>
<hr />
<%= render partial: "new" %>
```
can you see the partial added to the bottom of the html? Remember that partial needs an instance of a todo to work `@todo` so make sure you add this in the controller method for show, it will be then in scope for the partial to reference.
```ruby
  def show
    @todo = Todo.new
    @todos = Todo.all
  end
```
This complete the session on basic rails.

[Back](https://github.com/bmordan/walkthroughs)
